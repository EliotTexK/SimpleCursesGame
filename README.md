# SimpleCursesGame

An ascii roguelike game engine that intends to implement an "Entity Component Framework" like the ones found in games like Caves of Qud.

## Entity Component Framework
To me, ECF is a way for different objects in a game to interact anonymously. Every game object represented in an ECF is made of components, which recieve events and interpret them in whatever way that they want. As you mix and match components, game objects have the potential to be more than the sum of their parts, while recycling the same components in different circumstances allows for code reusability and logically consistent game mechanics. I would compare it to the "Unix Philosophy". Things get complicated, though. When we send events, do we send them to the objects that contain the components, or to the components themselves? The order in which events are sent/recieved matters, since events can be altered before being passed on to different components.

## Purpose of This Project
I'm very inspired by the game Caves of Qud. In fact, according to Steam, I've played it for an embarrasing amount of hours. An issue with Qud is how it represents events with strings. Now, I could see how something like that makes things easier for the programmer. However, as much as C# is good with string handling (as Qud uses C#/Unity), doing things this way causes performance issues. Caves of Qud, a game which looks like [this](https://user-images.githubusercontent.com/21148680/179429845-7fd5d997-ead3-49e9-ae6a-f6d6b4ecc659.png) sometimes lags on my high-end gaming rig... Qud's co-creator, Brian Bucklew, [admits to this flaw](https://www.youtube.com/watch?v=U03XXzcThGU). Though the game is still in early access, it seems that the dev team has no intention of changing the fundamental qualities of a functioning game engine that has been in the works for over a decade (oh no, how dare they?!?). That's why I'm trying to design a system that doesn't rely on strings. Ideally, events should be able to contain arbitrary data, and have some sort of size limitation. Think network packets. Also, for the sake of optimization, I wanted to manage memory. C++ provides the ability to do this, while still having OOP concepts that are important for organizing code. Perhaps that's why the language is a standard of sorts for writing game engines (at least in the world of AAA). So far, the game uses ascii graphics, but I would love to implement real graphics using SDL. However, I'm not good at making sprites.  

## Contributing
Keep in mind that when it comes to maintaining repositories, I am an amateur. In fact, you could say the goals of this project are lofty for somebody like me. But, that's the point: I'm trying to "git gud". At the time of writing this, I am a CS student currently working a non-coding summer job to help pay for school. Once school starts, I would expect to be busy with that. My main goals for this project are to learn and experiment. As of now, I have not set any deadlines for myself.  
That being said, if YOU, who are reading this, would like to contribute graphics, I will implement them. If you would like to suggest objects/game mechanics, I will implement them. If you would like to code objects/components on top of the engine that has been written, feel free to fork the repo. Ideally, there needs to be a system for separating the engine code from the component code. This has not yet been implemented. But, if you have ideas for such a system, I'm all ears. In fact, if you have ideas for improving the engine in terms of optimization and/or maintainability, you can contact me or send me a pull request (I'm a noob when it comes to merging them, though). Talk at/to me. I'm looking for collaborators.

My email is eliotkimmelcentillion@gmail.com, but that silly handle is subject to change.
